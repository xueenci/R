---
title: "learn R"
author: "EnCi"
date: "2020/5/21"
output:
  html_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# R for data science 学习笔记
# [参考图书](https://r4ds.had.co.nz/data-visualisation.html#coordinate-systems)

# 1. 探索数据
## 1.1 可视化
```{r load packages, include=FALSE}
library(tidyverse)
```

### ggplot2
* aes
* geom
* facet

```{r 使用模板, echo=TRUE}
# ggplot(data = <DATA>) + 
#   <GEOM_FUNCTION>(
#      mapping = aes(<MAPPINGS>),
#      stat = <STAT>, 
#      position = <POSITION>
#   ) +
#   <COORDINATE_FUNCTION> +
#   <FACET_FUNCTION>

```


#### 美学特征 aes


   * ![图点类型](https://d33wubrfki0l68.cloudfront.net/58a48d625b4bd494cd685dd9998f5c74e9c16907/211c6/visualize_files/figure-html/shapes-1.png)

```{r 美学特征aes, echo=TRUE}
ggplot(data=mpg)+
  geom_point(mapping = aes(x=displ,y=hwy))#散点图

###用法
#ggplot(data = <DATA>) + 
#  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))

# 
# nrow(mpg)
# ncol(mpg)
# dim(mpg)
# ?mpg
# ggplot(data=mpg)+
#   geom_point(mapping = aes(cyl,hwy))

#数据的维度不仅可以有value,还可以有level
#比如不同种类的不同值，这个不同种类可以用不同形状或者不同颜色、不同大小对level进行区分。
#pch 散点图的性状，内置有25种，
# ![图点类型](https://d33wubrfki0l68.cloudfront.net/58a48d625b4bd494cd685dd9998f5c74e9c16907/211c6/visualize_files/figure-html/shapes-1.png)

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, color = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, size = class))
#> Warning: Using size for a discrete variable is not advised.

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, alpha = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy, shape = class))

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), color = "blue")

# ggplot(data = mpg) + 
#   geom_point(mapping = aes(x = displ, y = hwy, color = displ<5)

```

#### 分面 facets_wrap

```{r 分面, echo=TRUE}
 ggplot(data = mpg) + 
   geom_point(mapping = aes(x = displ, y = hwy)) + 
   facet_wrap(~ class, nrow = 2) #facet_wrap ~这个后面跟一个分类变量
 
 ggplot(data = mpg) + 
   geom_point(mapping = aes(x = displ, y = hwy)) + 
   facet_grid(.~ cty)
 
 
 
 ggplot(data = mpg) + 
   geom_point(mapping = aes(x = displ, y = hwy)) +
   facet_grid(drv ~ .)
 
 ggplot(data = mpg) + 
   geom_point(mapping = aes(x = displ, y = hwy)) +
   facet_grid(. ~ cyl)
             

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ .)


ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(. ~ cyl)
```

#### 图形对象 geom
Geometric objects geom就是这个的缩写  

#### stat 要描述的统计量，如果是一个分类变量，Y轴肯定要有相应的统计量，比如条形图默认的是stat=(count) 也可以改成prop
```{r 图形对象, echo=TRUE}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))#散点图

ggplot(data = mpg) + 
  geom_smooth(mapping = aes(x = displ, y = hwy)) #拟合曲线

ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy))+
  geom_smooth(mapping = aes(x = displ, y = hwy,linetype=drv))#添加拟合曲线图层
ggplot(data=mpg)+  
  geom_smooth(mapping = aes(x = displ, y = hwy,colour=drv))#添加拟合曲线图层

#geom_smooth(se=F) SE指的曲线是包不包括散点的区间


#条形图 geom_bar
ggplot(data=diamonds)+
  geom_bar(mapping = aes(x=cut)) #横坐标cut等级，纵坐标计数（bar底层是有计数函数的）

ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = stat(prop), group = 1))# 百分比

#当以分类变量作为Fill的时候，有三个位置可以选择，identity（堆叠） dodge,合并， fill 填充满

```

#### 坐标系 coord

```{r 坐标系,}
#coord_flip()转换坐标系 
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot()
ggplot(data = mpg, mapping = aes(x = class, y = hwy)) + 
  geom_boxplot() +
  coord_flip()


#coord_polar 转化为极坐标系（玫瑰图就是这样做的）
bar <- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_flip()
bar + coord_polar()
```


## 1.2数据转换
### 学习dplyr 清理数据
- filter 
- arrange
- select 
- mutate 
- summarise
- group_by

#### 筛选
```{r 筛选, eval=FALSE, include=FALSE}
install.packages("nycflights13")
library(nycflights13)
library(tidyverse)
flights
#filter
jan1 <- filter(flights,month==1,day==1)#(数据集，筛选条件)
hea

```
逻辑符号  
&和  
|或  
!非  
%in% 后面可以跟向量 %in%c( ),也可以把字符型的放在里面

#### 缺失值
is.na()  
sum(is.na())  
drop_na(x,value)  

#### arrange排序
arrange(flights,year,month,year)#默认升序，desc()改为降序
```{r 排序, eval=FALSE, message=FALSE, warning=TRUE, include=FALSE, paged.print=FALSE}
arrange(flights,year,month,year)
#NA永远在最后

```

#### 选择变量  select
select(flight,year,month,day)

starts_with("abc)选择以abc开头的变量

end_with("abc") 选择以abc为结尾的变量

contains（“abc”）选择名称中包含abc的变量

matches （）正则匹配选择相应的变量

num_range（“x”,1:3) 匹配选择x1 x2 x3
```{r 选择变量, eval=FALSE, include=FALSE}
select(flights,year,month,year)

select(flights, year:day)# Select all columns between year and day (inclusive)
select(flights, -(year:day))# Select all columns except those from year to day (inclusive)

```




```{r NBA数据示例,}
library(SportsAnalytics)
NBA1920<- fetch_NBAPlayerStatistics("19-20") 
select1 <- select(NBA1920,Name,starts_with("Three"),ends_with("Made"))#start_with 和end_with之间的逗号是或者的意思以three开头以made结尾

select2 <- select(NBA1920,Name:FieldGoalsMade,-TotalMinutesPlayed)#从name到FieldGoalsMade..不要TotalMinutesPlayed

filter1 <- filter(NBA1920,TotalMinutesPlayed>100)
filter1[,2:6]

filter2 <- filter(NBA1920,Team %in% c ("BOS","SAN"))

# 也可以先计算再筛选

filter3 <- filter(NBA1920,ThreesMade/ThreesAttempted>0.7)

head(filter3)

filter3 <- filter(NBA1920,ThreesMade/ThreesAttempted>0.7&GamesPlayed>3)
head(filter3)





```



#### 重命名
```{r 重命名, eval=FALSE, include=FALSE}
rename(flights,tail_num=tail_num)#新名字=旧名字

```

#### 添加新变量
```{r 添加新变量, eval=FALSE, include=FALSE}
#mutate 数据变换产生新变量，产生新的列
flights_sml <- select(flights, 
  year:day, 
  ends_with("delay"), 
  distance, 
  air_time
)
mutate(flights_sml,
  gain = dep_delay - arr_delay,
  speed = distance / air_time * 60
)

#transmute 产生新变量，并且只保留新变量

#数学运算
#%/% 整除取整
#%% 取余数
# log() log2() log10()
#连加 连乘 cumsum(), cumprod(), cummin(), cummax()

```

#### 分组和总数

n()代表记录数  

n_distinct()代表不重复的记录数


```{r 分组, eval=FALSE, include=FALSE}
by_day <- group_by(flights, year, month, day)
summarise(by_day, delay = mean(dep_delay, na.rm = TRUE))


sum1 <-summarise(NBA1920,nPlayer=n(),nTeam=n_distinct(Team),nPosition=n_distinct(Position))
sum1
#分组group_by
#解开分组ungroup

```

#### 管道操作
主要是为了减少中间变量的命名，缩短代码长度，相当于:用上一步产生的数据然后...（用这个数据然后...）

```{r 管道操作, eval=FALSE, include=FALSE}
by_dest <- group_by(flights, dest)
delay <- summarise(by_dest,
  count = n(),
  dist = mean(distance, na.rm = TRUE),
  delay = mean(arr_delay, na.rm = TRUE)
)
delay <- filter(delay, count > 20, dest != "HNL")

delays <- flights%>%
  group_by(dest)%>%
  summarise(
    count=n(),
    dist=mean(distance,na.rm = T),
    delay=mean(arr_delay,na.rm = T)
            )%>%
  filter(count>20,dest !='HNL')

# sd(x), IQR(x), mad(x) min(x), quantile(x, 0.25), max(x) first(x), nth(x, 2), last(x)
# n_distinct(x)#去重后的

```
#### count计数 
很有用

## 1.3探索性分析EDA
先学会提出问题，在大量的问题中找到高质量的问题

变量是什么类型  
协变量是什么类型

变异：不同观测之间的差别，可以在分析之前先看变量的分布（可视化）
### 对于分类变量，可以使用比如条形图：
```{r 分类变量条形图, echo=FALSE}
ggplot(data=diamonds)+
  geom_bar(mapping=aes(x=cut))
#底层默认是计数count
```

### 对于连续变量，可以使用直方图
```{r 连续变量直方图,}
ggplot(data=diamonds)+
  geom_histogram(mapping = aes(x=carat),binwidth = 0.5) #底层也是计数
ggplot(data=diamonds)+
  geom_histogram(mapping = aes(x=carat),binwidth = 0.1)
#binwidth是组距,不同的组距会有不一样的感受

#画多组直方图可以选择用线代替
ggplot(data = diamonds, mapping = aes(x = carat, colour = cut)) +
  geom_freqpoly(binwidth = 0.1)
```

```{r 设置坐标轴限制,}
#设置坐标轴限制
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))
```


#### ifelse 语句，ifelse(逻辑判断，是的值，否的值)

### 一个分类变量，一个连续变量，两变量之间的关系，分布，可以用厢式图
```{r 箱式图,}
ggplot(data=diamonds)+
  geom_boxplot(mapping= aes(x=cut,y=price))
```


#### reorder可以对分类变量重新排序，geom_boxplot(mapping=aes(x=reorder(class,hwy,FUN=median),y=hwy))+coord_flip

```{r 一个分类变量，一个连续变量,}
ggplot(data=diamonds)+
  geom_violin(mapping= aes(x=cut,y=price))

ggplot(data=diamonds)+
  geom_histogram(mapping= aes(x=price))+
  facet_wrap(~ cut, nrow = 2)

ggplot(data=diamonds)+
  geom_freqpoly(mapping=aes(x=price,colour=cut))

ggplot(data=diamonds)+
  geom_jitter(mapping=aes(x=cut,y=price))
```

### 两个分类变量， 对两个分类变量进行计数（有点类似于列联表）
```{r 两个分类变量,}
ggplot(data=diamonds)+
  geom_count(mapping=aes(x=cut,y=color))

```
```{r 两个分类变量 瓷砖图,}
diamonds %>% 
  count(color, cut) %>%  
  ggplot(mapping = aes(x = color, y = cut)) +
    geom_tile(mapping = aes(fill = n))
diamonds %>% 
  count(color, cut) %>%  
  ggplot(mapping = aes(x = cut, y = color)) +
    geom_tile(mapping = aes(fill = n))

```

### 两个连续变量 可以用散点图
```{r 两个连续变量 散点图,}
ggplot(data=diamonds)+
  geom_point(mapping=aes(x=carat,y=price))


ggplot(data = diamonds) + 
  geom_point(mapping = aes(x = carat, y = price), alpha = 1 / 100)


ggplot(data = diamonds) +
  geom_bin2d(mapping = aes(x = carat, y = price))


ggplot(data = diamonds) +
  geom_hex(mapping = aes(x = carat, y = price))
```

### 模型
```{r 模型,}
library(modelr)

mod <- lm(log(price) ~ log(carat), data = diamonds)
diamonds2 <- diamonds %>% 
  add_residuals(mod) %>% 
  mutate(resid = exp(resid))

ggplot(data = diamonds2) + 
  geom_point(mapping = aes(x = carat, y = resid))
```

# 2. 处理数据，数据清理 data wrangle

数据工作的流程是：

导入数据，整理数据，数据转化，可视化，模型，沟通  

tidyr 取代了reshape和reshape2

## 2.1 Tibble

```{r 把 普通的data frame 转换成 tibble, eval=FALSE, include=FALSE, paged.print=FALSE}
as_tibble(iris)

tibble(
  x=1:5,
  y=1,#y可以自动补齐，类似于numpy
  z=x^2+y
)

#也可以把tibble转换为data.frame
as.data.frame(iris)
```

tibble不会自动把字符型转换为factor，不改变变量名，不创建行名

```{r tribble, eval=FALSE, include=FALSE}
tribble(
  ~x, ~y, ~z,
  #--|--|----
  "a", 2, 3.6,
  "b", 1, 8.5
)

#可以手动录入数据
```
tibble会自动打印前十行，会显示每个变量的类型


## 2.2 数据导入

最常用的是read.csv read.table (read_csv,read_table)

```{r read_csv,}
#read_csv 和read.csv 是不同的，read_csv可以手动录入数据
# read_csV读取文件之后会自动显示每一列变量的类型
#手动录入的话默认会把第一行当做列名
read_csv("1,2,3\n4,5,6", col_names = FALSE)


```


```{r read_csv1,}
read_csv("The first line of metadata
  The second line of metadata
 x,y,z
  1,2,3", skip = 2)#跳过前两行

read_csv("# A comment I want to skip
  x,y,z
  1,2,3", comment = "#")#用#号做注释

```

read_csv和read.csv对比

They are typically much faster (~10x) than their base equivalents. Long running jobs have a progress bar, so you can see what’s happening. If you’re looking for raw speed, try data.table::fread(). It doesn’t fit quite so well into the tidyverse, but it can be quite a bit faster.

They produce tibbles, they don’t convert character vectors to factors, use row names, or munge the column names. These are common sources of frustration with the base R functions.

They are more reproducible. Base R functions inherit some behaviour from your operating system and environment variables, so import code that works on your computer might not work on someone else’s.

### 解析向量
```{r 解析向量, eval=FALSE, include=FALSE}
# parse_*()
str(parse_logical(c("TRUE", "FALSE", "NA")))
str(parse_integer(c("1", "2", "3")))
str(parse_date(c("2010-01-01", "1979-10-14")))

```


#### 数字、字符串、时间、文件
默认格式最好是UTF-8  
guess_encoding(charToRaw(x2))  
parse_datetime("2010-10-01T2010")  

guess_parser(c("12,352,561")) 自动判断是什么类型的数据  

haven reads SPSS, Stata, and SAS files.  

readxl reads excel files (both .xls and .xlsx).  

DBI, along with a database specific backend (e.g. RMySQL, RSQLite, RPostgreSQL etc) allows you to run SQL queries against a database and return a data frame.

For hierarchical data: use jsonlite (by Jeroen Ooms) for json, and xml2 for XML. 


### 输出文件
```{r 输出文件, eval=FALSE, include=FALSE}
write_csv(challenge, "challenge.csv")
```
feather包 可以输出二进制文件 .feather 


## 2.3 整理数据

### 长短格式转换  pivot_longer() and pivot_wider().

```{r 转换成长格式,eval=FALSE, include=FALSE}
table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
#> # A tibble: 6 x 3
#>   country     year   cases
#>   <chr>       <chr>  <int>
#> 1 Afghanistan 1999     745
#> 2 Afghanistan 2000    2666
#> 3 Brazil      1999   37737
#> 4 Brazil      2000   80488
#> 5 China       1999  212258
#> 6 China       2000  213766


tidy4a <- table4a %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "cases")
tidy4b <- table4b %>% 
  pivot_longer(c(`1999`, `2000`), names_to = "year", values_to = "population")
left_join(tidy4a, tidy4b)# 左合并

```


### 长宽数据转换
gather:宽转长

相当于，重复测量数据中，一个人测了很多次，那每个人的名字就是key(有点类似于主键的意思),不同的测量就是vaule


spread
相当于，长型的重复测量数据中，一个人测了很多次，找到那个作为key的变量，然后把值分开为不同的测量


```{r 长宽数据转换,}
airquality
airquality2 <- gather(data = airquality,key = Type,value = value,Ozone,Solar.R,Wind,Temp)
airquality2

#
airquality3 <- spread(data = airquality2,key = Type,value=value)
airquality3
```


### 分列和合并
![分列](C:/Users/xueenci/Desktop/R/1.png)

```{r 分列和合并, eval=FALSE, include=FALSE}
table3 %>% 
  separate(rate, into = c("cases", "population"))
#可以指定分隔符
  separate(rate, into = c("cases", "population"), sep = "/")
#> # A tibble: 6 x 4
#>   country      year cases  population
#>   <chr>       <int> <chr>  <chr>     
#> 1 Afghanistan  1999 745    19987071  
#> 2 Afghanistan  2000 2666   20595360  
#> 3 Brazil       1999 37737  172006362 
#> 4 Brazil       2000 80488  174504898 
#> 5 China        1999 212258 1272915272
#> 6 China        2000 213766 1280428583

table5 %>% 
  unite(new, century, year, sep = "")
  
```

### 缺失值
两种 一种已经显示NA 一种就是不显示出来
complete 可以把不显示出来的显示为NA


### 数据清理整体流程示例
```{r eval=FALSE, include=FALSE}
#利用who的肺结核数据
tidyr::who
who %>%
  pivot_longer(
    cols = new_sp_m014:newrel_f65,
```


```{r eval=FALSE, include=FALSE}
names_to = "key", 
    values_to = "cases", 
    values_drop_na = TRUE
  ) %>% 
  mutate(
    key = stringr::str_replace(key, "newrel", "new_rel")
  ) %>%
  separate(key, c("new", "var", "sexage")) %>% 
  select(-new, -iso2, -iso3) %>% 
  separate(sexage, c("sex", "age"), sep = 1)

```

## 2.4 关系型数据（总体来讲有点像数据库的内容，不要忘了MYSQL的增删改查）
多个table 之间有关系的数据叫关系型数据， 类似于SQL多个库，每张表之间有一定的关系，需要对这些表进行操作

总的来说三种关联:  
- Mutating joins  
向另一个表中匹配的观测添加新变量，也就是对应到个体增加新的变量（相当于筛选变量）
- Filtering joins  
基于另一张表是否和这张表的观测匹配来筛选数据，比如两年随访两张表，在第二年中选取第一年随访过的 (相当于筛选观测)
- Set operations  
集合操作，它将观察值视为集合元素。


### mutation joins
```{r 关系型数据导入准备, eval=FALSE, include=FALSE}
library(tidyverse)
library(nycflights13)

#这个包，包含了关于飞行数据的四张表。
airlines
airports
planes
weather
```

##### keys
键：关联两张表的数据（两张表联系起来的关键变量）两种
-  主键： 唯一识别本表中的值
-  外键：唯一识别另外一个表的值
（其实可以有多个键）
如果没有合适的主键 可以使用代理键 比如mutate新建一个键或者用row_number

```{r eval=FALSE, include=FALSE}
flights2 <- flights %>% 
  select(year:day, hour, origin, dest, tailnum, carrier)
flights2
```

###  数据表连接



```{r 理解数据库连接, eval=FALSE, include=FALSE}
#示例数据
x <- tribble(
  ~key, ~val_x,
     1, "x1",
     2, "x2",
     3, "x3"
)
y <- tribble(
  ~key, ~val_y,
     1, "y1",
     2, "y2",
     4, "y3"
)

```

#### 内连接

![内连接示意图](C:/Users/xueenci/Desktop/R/3.png)

```{r 内连接 inner join, eval=FALSE, include=FALSE}
x%>%
  inner_join(y,by="key")
# 合并具有相同key的值，输出结果
#没有匹配到的Key不会输出，有点类似于求交集，两个都有的key，把value合并输出到一个新的数据集

```

#### 外连接

![三种外连接图例](C:/Users/xueenci/Desktop/R/2.png)

##### 左连接
以左表为主表，保留左表所有的记录。在右表中寻找一个key的值合并，没有的记为空，而右表中没对应上的key则直接舍去


```{r 左连接, eval=FALSE, include=FALSE}

flights2 %>%
  select(-origin, -dest) %>% 
  left_join(airlines, by = "carrier")
```

##### 右连接
以右表为主表，保留右表所有的记录。在左表中寻找一个key的值合并，没有的记为空，而左表中没对应上的key则直接舍去

```{r 右连接, eval=FALSE, include=FALSE}
flights2%>%
  select(-origin,-dest)%>%
  right_join(airlines,by="carrier")

```


##### 全连接
两个表所有的记录都保留，没有匹配上的当作是空值

```{r 全连接, eval=FALSE, include=FALSE}
flights2%>%
  full_join(airlines,by="carrier")

```

#### 当一个表有重复的键的时候，重复的键对应匹配多次

![当一个表有重复的键的时候](C:/Users/xueenci/Desktop/R/4.png)


#### 当多个表都有重复的键的时候，重复的键排列组合，都会放入新的表中


![当多个表有重复的键的时候](C:/Users/xueenci/Desktop/R/5.png)

by如果为NULL则匹配所有相同的变量


与基础merge函数可以实现一样的功能
|dplyr  |merge|
|-------------- | -------:  |:----:|
|inner_join(x, y)	| merge(x, y)|
|left_join(x, y)	  | merge(x, y, all.x = TRUE)|
|right_join(x, y)	 | merge(x, y, all.y = TRUE) |
|full_join(x, y)	  | merge(x, y, all.x = TRUE, all.y = TRUE)|

与SQL语言也可以有一样的效果
|dplyr    | sql |
|----------    | ---------: |:--------:|
|inner_join(x, y, by = "z")	| SELECT * FROM x INNER JOIN y USING (z)|
|left_join(x, y, by = "z")	| SELECT * FROM x LEFT OUTER JOIN y USING (z)|
|right_join(x, y, by = "z")	| SELECT * FROM x RIGHT OUTER JOIN y USING (z)|
|full_join(x, y, by = "z")	| SELECT * FROM x FULL OUTER JOIN y USING (z)|


### fileter joins

semi_join(x, y) keeps all observations in x that have a match in y.  

anti_join(x, y) drops all observations in x that have a match in y.

## 2.5 字符串操作  

字符串操作用str_能自动补全很多

```{r 字符串长度,}
length("aaa")
str_length("aaa")

```

####组合字符串
```{r str_c,}
str_c("x","y")

str_c("x","y",sep=",")

# 把一个向量折叠成一个字符串
str_c(c("x", "y", "z"), collapse = ", ")

```

#### 替换字符串

### 正则表达式

#####  .代表同一行任意一个字符，如果本身就想找"."那就要用\\.

##### 锚定一个字符的首尾，if you begin with power (^), you end up with money ($).
```{r 正则表达式}
x <- c("apple", "banana", "pear")
str_view(x, "an")

str_view(x, ".a.")


x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")


str_view(x, "^apple$") #锚定字符串首尾
```

